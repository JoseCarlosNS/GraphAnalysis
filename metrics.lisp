(load "graph.lisp")
(load "utils.lisp")

;; Returns the density of the graph
(defmethod density ((g graph))
    (let ((num-of-nodes nil) (num-of-edges nil))
        (setf num-of-nodes (gethash "number-of-nodes" (properties g)))
        (setf num-of-edges (gethash "number-of-edges" (properties g)))
        (if (= (gethash "type" (properties g)) 1)
            (float (/ num-of-edges (* (1- num-of-nodes) num-of-nodes)))
            (float (/ num-of-edges (/ (* (1- num-of-nodes) num-of-nodes) 2))))))


;; Returns an array with the outcoming (and another with the incoming, if the graph is directed) degrees of
;; each node of the graph
(defmethod degrees ((g graph) &optional &key (verbose nil))
    (let ((out-array nil) (in-array nil) (adj-list nil) (number-of-nodes nil) (total-time 0) (type nil))
        (setf number-of-nodes (gethash "number-of-nodes" (properties g)))
        (setf adj-list (adj-list g))
        (setf type (gethash "type" (properties g)))
        (setf out-array (make-array number-of-nodes :initial-element 0))
        (when (= 1 type)
            (setf in-array (make-array number-of-nodes :initial-element 0)))
        (when verbose
            (progn
                (terpri)
                (format t "Calculating degrees...")
                (terpri)))
        (dotimes (node1 number-of-nodes)
            (let ((start-time nil) (end-time nil) (adj-nodes nil))
                (setf start-time (get-internal-real-time))
                (setf adj-nodes (aref adj-list node1))
                (setf (aref out-array node1) (list-length adj-nodes))
                (when (= 1 type)
                    (dolist (node2 adj-nodes)
                        (incf (aref in-array node2))))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress (1+ node1) number-of-nodes total-time))))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)))
        (if (= 1 type)
            (list out-array in-array)
            out-array)))


;; Returns an list (x y z) where:
;;     x -> the expected degree of the graph, (OUTCOMING INCOMING) if directed, OUTCOMING if otherwise.
;;     y -> an array with the distribution of all outcoming degrees.
;;     z -> like y, but with incoming degrees, only present if graph is directed.
(defmethod degree-dist ((g graph) &optional &key (verbose nil))
    (let ((degrees-out nil) (degrees-in nil) (degree-dist-out nil) (degree-dist-in nil) 
            (number-of-nodes nil) (type nil) (total-time 0) (expt-degree nil))
        (setf number-of-nodes (gethash "number-of-nodes" (properties g)))
        (setf degrees-out (degrees g :verbose verbose))
        (setf type (gethash "type" (properties g)))
        (setf degree-dist-out (make-array number-of-nodes :initial-element 0))
        (setf expt-degree 0)
        (when (= 1 type)
            (progn
                (setf expt-degree (list 0 0))
                (setf degrees-in (second degrees-out))
                (setf degrees-out (first degrees-out))
                (setf degree-dist-in (make-array number-of-nodes :initial-element 0))))
        (when verbose
            (progn
                (terpri)
                (format t "Calculating degree distribution:")
                (terpri)))
        (dotimes (i number-of-nodes)
            (let ((out nil) (in nil) (start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf out (aref degrees-out i))
                (if (= 1 type)
                    (progn
                        (setf in (aref degrees-in i))
                        (incf (aref degree-dist-in in))
                        (incf (first expt-degree) out)
                        (incf (second expt-degree) in))
                    (incf expt-degree out))
                (incf (aref degree-dist-out out))
                (setf end-time (get-internal-real-time))
                (setf end-time (decf end-time start-time))
                (incf total-time end-time)
                (when verbose
                    (print-progress (1+ i) (* 2 number-of-nodes) total-time))))
        (dotimes (i number-of-nodes)
            (let ((start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf (aref degree-dist-out i) (/ (aref degree-dist-out i) number-of-nodes))
                (when (= 1 type)
                    (setf (aref degree-dist-in i) (/ (aref degree-dist-in i) number-of-nodes)))
                (setf end-time (get-internal-real-time))
                (setf end-time (decf end-time start-time))
                (incf total-time end-time))
                (when verbose
                    (print-progress (+ number-of-nodes (1+ i)) (* 2 number-of-nodes) total-time)))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)))
        (if (= 1 type)
            (progn
                (setf (first expt-degree) (/ (first expt-degree) number-of-nodes))
                (setf (second expt-degree) (/ (second expt-degree) number-of-nodes))
                (list expt-degree degree-dist-out degree-dist-in))
            (list (/ expt-degree number-of-nodes) degree-dist-out))))

;; Returns the distances and parents array and the bfs-tree for the graph given the origin point as the node origin
(defmethod bfs-search ((g graph) origin)
    (let ((distances nil) (bfs-tree nil) (unvisited-nodes nil) (adj-list nil))
        (setf bfs-tree (make-array (gethash "number-of-nodes" (properties g)) :initial-element -1))
        (setf distances (make-array (gethash "number-of-nodes" (properties g)) :initial-element -1))
        (setf unvisited-nodes (make-queue :head nil :tail nil))
        (queue-put origin unvisited-nodes)
        (setf (aref bfs-tree origin) origin)
        (setf (aref distances origin) 0)
        (setf adj-list (adj-list g))
        (loop
            (let ((current-node nil))
                (setf current-node (queue-pop unvisited-nodes))
                (dolist (neighbor-node (aref adj-list current-node))
                    (when (= -1 (aref bfs-tree neighbor-node))
                        (progn
                            (setf (aref bfs-tree neighbor-node) current-node)
                            (setf (aref distances neighbor-node) (1+ (aref distances current-node)))
                            (queue-put neighbor-node unvisited-nodes)))))
                (when (queue-empty unvisited-nodes)
                    (return (list distances bfs-tree))))))

;; Run an analysis on the graph g, to get its metrics. If verbose it will print information about what metrics its
;; currently working on and the progress of the algorithm
(defmethod run-analysis ((g graph) &optional &key (verbose nil))
    (let ((diameter nil) (total-distance nil) (progress nil) (max-num-paths nil) (total-time nil)
           (density nil) (expt-degree nil) (type nil) (num-nodes nil) (unconnected nil) (degree-dist nil)) 
        (setf progress 0)
        (setf total-distance 0)
        (setf num-nodes (gethash "number-of-nodes" (properties g)))
        (setf type (gethash "type" (properties g)))
        (setf max-num-paths (* num-nodes (1- num-nodes)))
        (when (= 2 type)
            (setf max-num-paths (/ max-num-paths 2)))
        (setf total-time 0)
        (setf diameter 0)

        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Analysis starting...~%")
                (terpri)))

        (setf density (density g))
        (setf degree-dist (degree-dist g :verbose verbose))
        (setf expt-degree (first degree-dist))
        (setf degree-dist (if (= 1 type) (cdr degree-dist) (second degree-dist)))

        (when verbose
            (progn
                (terpri)
                (format t "Calculating average distance and efficiency...")
                (terpri)))
        
        (dotimes (node1 num-nodes)
            (let ((bfs-tree nil) (distance-array nil) (start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf bfs-tree (bfs-search g node1))
                (incf progress)
                (setf distance-array (first bfs-tree))
                (setf bfs-tree (second bfs-tree))
                (dotimes (y (if (= 2 type) (- num-nodes node1) num-nodes))
                    (let ((distance nil) (node2 nil))
                        (setf node2 (if (= 2 type) (+ y node1) y))
                        (when (not (equal node1 node2))
                            (setf distance (aref distance-array node2))
                            (when (= -1 distance)
                                (progn
                                    (when verbose
                                        (terpri)
                                        (format t "~%The graph is unconnected, stopping analysis...")
                                        (terpri))
                                    (return (setf unconnected t))))
                            (when (> distance diameter)
                                (setf diameter distance))
                            (incf total-distance distance))))
                (when unconnected
                    (return nil))
                (setf end-time (get-internal-real-time))
                (setf end-time (- end-time start-time))
                (incf total-time end-time)
                (when verbose
                    (progn
                        (print-progress progress num-nodes total-time)))))
        (if unconnected
            nil
            (progn
                (when verbose
                    (progn
                        (terpri)
                        (format t "Analysis complete!")
                        (terpri)
                        (dotimes (n 50)
                            (princ "#"))
                        (terpri)))
                (setf total-distance (/ total-distance max-num-paths))
                (setf (gethash "diameter" (properties g)) diameter) 
                (setf (gethash "average-distance" (properties g)) total-distance)
                (setf (gethash "average-efficiency" (properties g)) (/ 1 total-distance))
                (setf (gethash "density" (properties g)) density)
                (setf (gethash "expected-degree" (properties g)) expt-degree)
                (setf (gethash "degree-dist" (properties g)) degree-dist)
                t))))

;; Generates a number of random graphs, analyses them and gives metrics like average diameter and conectedness.
;; Unconnected graphs are not counted in the average diameter calculation
(defmethod random-graphs-analysis (number-of-graphs number-of-nodes type edge-prob &optional &key (verbose nil))
    (let ((average-diameter 0) (unconnected-graphs 0) (total-time 0) (average-degree-dist nil) (connected-graphs 0)
            (distance 0) (efficiency 0))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics...")
                (terpri)))
        (if (= 1 type)
            (progn
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist)
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist))
            (setf average-degree-dist (make-array number-of-nodes :initial-element 0)))
        (dotimes (n number-of-graphs)
            (let ((diameter nil) (graph nil) (degree-dist nil) (start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf graph (random-graph number-of-nodes type edge-prob))
                (if (run-analysis graph)
                    (progn
                        (setf diameter (gethash "diameter" (properties graph)))
                        (incf average-diameter diameter)
                        (setf degree-dist (gethash "degree-dist" (properties graph)))
                        (incf distance (gethash "average-distance" (properties graph)))
                        (incf efficiency (gethash "average-efficiency" (properties graph)))
                        (dotimes (index number-of-nodes)
                            (if (= 2 type)
                                (incf (aref average-degree-dist index) (aref degree-dist index))
                                (progn
                                    (incf (aref (first average-degree-dist) index) (aref (first degree-dist) index))
                                    (incf (aref (second average-degree-dist) index) (aref (second degree-dist) index))))))
                    (incf unconnected-graphs))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress n number-of-graphs total-time))))
        (setf connected-graphs (- number-of-graphs unconnected-graphs))
        (when (> connected-graphs 0)
            (dotimes (index number-of-nodes)
                (if (= 1 type)
                    (let ((out nil) (in nil))
                        (setf out (aref (first average-degree-dist) index))
                        (setf in (aref (second average-degree-dist) index))
                        (setf out (/ out connected-graphs))
                        (setf in (/ in connected-graphs))
                        (setf (aref (first average-degree-dist) index) out)
                        (setf (aref (second average-degree-dist) index) in))
                    (let ((out nil))
                        (setf out (aref average-degree-dist index))
                        (setf out (/ out connected-graphs))
                        (setf (aref average-degree-dist index) out)))))
        (setf average-diameter (/ average-diameter (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf distance (/ distance (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf efficiency (/ efficiency (if (= 0 connected-graphs) 1 connected-graphs)))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        (setf unconnected-graphs (if (= 0 unconnected-graphs) 1 (/ connected-graphs number-of-graphs)))
        (list average-diameter unconnected-graphs distance efficiency average-degree-dist)))

;; Generates a number of small-world random graphs and calculates average metrics
(defmethod small-world-graphs-analysis (number-of-graphs number-of-nodes type degree link-prob &optional &key (verbose nil))
    (let ((average-diameter 0) (unconnected-graphs 0) (total-time 0) (average-degree-dist nil) (connected-graphs 0)
            (distance 0) (efficiency 0))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics...")
                (terpri)))
        (if (= 1 type)
            (progn
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist)
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist))
            (setf average-degree-dist (make-array number-of-nodes :initial-element 0)))
        (dotimes (n number-of-graphs)
            (let ((diameter nil) (graph nil) (degree-dist nil) (start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf graph (small-world number-of-nodes type degree link-prob))
                (if (run-analysis graph)
                    (progn
                        (setf diameter (gethash "diameter" (properties graph)))
                        (incf average-diameter diameter)
                        (setf degree-dist (gethash "degree-dist" (properties graph)))
                        (incf distance (gethash "average-distance" (properties graph)))
                        (incf efficiency (gethash "average-efficiency" (properties graph)))
                        (dotimes (index number-of-nodes)
                            (if (= 2 type)
                                (incf (aref average-degree-dist index) (aref degree-dist index))
                                (progn
                                    (incf (aref (first average-degree-dist) index) (aref (first degree-dist) index))
                                    (incf (aref (second average-degree-dist) index) (aref (second degree-dist) index))))))
                    (incf unconnected-graphs))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress n number-of-graphs total-time))))
        (setf connected-graphs (- number-of-graphs unconnected-graphs))
        (when (> connected-graphs 0)
            (dotimes (index number-of-nodes)
                (if (= 1 type)
                    (let ((out nil) (in nil))
                        (setf out (aref (first average-degree-dist) index))
                        (setf in (aref (second average-degree-dist) index))
                        (setf out (/ out connected-graphs))
                        (setf in (/ in connected-graphs))
                        (setf (aref (first average-degree-dist) index) out)
                        (setf (aref (second average-degree-dist) index) in))
                    (let ((out nil))
                        (setf out (aref average-degree-dist index))
                        (setf out (/ out connected-graphs))
                        (setf (aref average-degree-dist index) out)))))
        (setf average-diameter (/ average-diameter (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf distance (/ distance (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf efficiency (/ efficiency (if (= 0 connected-graphs) 1 connected-graphs)))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        (setf unconnected-graphs (if (= 0 unconnected-graphs) 1 (/ connected-graphs number-of-graphs)))
        (list average-diameter unconnected-graphs distance efficiency average-degree-dist)))

;; Generates a number of scale-free random graphs and calculates average metrics
(defmethod scale-free-graphs-analysis (number-of-graphs number-of-nodes type edges-per-insertion &optional &key (verbose nil))
    (let ((average-diameter 0) (unconnected-graphs 0) (total-time 0) (average-degree-dist nil) (connected-graphs 0)
            (distance 0) (efficiency 0))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics...")
                (terpri)))
        (if (= 1 type)
            (progn
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist)
                (push (make-array number-of-nodes :initial-element 0) average-degree-dist))
            (setf average-degree-dist (make-array number-of-nodes :initial-element 0)))
        (dotimes (n number-of-graphs)
            (let ((diameter nil) (graph nil) (degree-dist nil) (start-time nil) (end-time nil))
                (setf start-time (get-internal-real-time))
                (setf graph (scale-free number-of-nodes type edges-per-insertion))
                (if (run-analysis graph)
                    (progn
                        (setf diameter (gethash "diameter" (properties graph)))
                        (incf average-diameter diameter)
                        (setf degree-dist (gethash "degree-dist" (properties graph)))
                        (incf distance (gethash "average-distance" (properties graph)))
                        (incf efficiency (gethash "average-efficiency" (properties graph)))
                        (dotimes (index number-of-nodes)
                            (if (= 2 type)
                                (incf (aref average-degree-dist index) (aref degree-dist index))
                                (progn
                                    (incf (aref (first average-degree-dist) index) (aref (first degree-dist) index))
                                    (incf (aref (second average-degree-dist) index) (aref (second degree-dist) index))))))
                    (incf unconnected-graphs))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress n number-of-graphs total-time))))
        (setf connected-graphs (- number-of-graphs unconnected-graphs))
        (when (> connected-graphs 0)
            (dotimes (index number-of-nodes)
                (if (= 1 type)
                    (let ((out nil) (in nil))
                        (setf out (aref (first average-degree-dist) index))
                        (setf in (aref (second average-degree-dist) index))
                        (setf out (/ out connected-graphs))
                        (setf in (/ in connected-graphs))
                        (setf (aref (first average-degree-dist) index) out)
                        (setf (aref (second average-degree-dist) index) in))
                    (let ((out nil))
                        (setf out (aref average-degree-dist index))
                        (setf out (/ out connected-graphs))
                        (setf (aref average-degree-dist index) out)))))
        (setf average-diameter (/ average-diameter (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf distance (/ distance (if (= 0 connected-graphs) 1 connected-graphs)))
        (setf efficiency (/ efficiency (if (= 0 connected-graphs) 1 connected-graphs)))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        (setf unconnected-graphs (if (= 0 unconnected-graphs) 1 (/ connected-graphs number-of-graphs)))
        (list average-diameter unconnected-graphs distance efficiency average-degree-dist)))

;; Calculates the metrics of random graphs (erdos and renyie) over p{0-100}, which is the probability of link between two nodes
(defmethod metrics-random-graph (number-of-graphs number-of-nodes type &optional &key (verbose nil))
    (let ((total-time 0) (metrics nil))
        (setf metrics '(nil nil nil nil nil))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics over p...")
                (terpri)))
        (do ((n 100 (1- n)))
            ((< n 0) metrics)
            (let ((start-time nil) (end-time nil) (result nil))
                (setf start-time (get-internal-real-time))
                (setf result (random-graphs-analysis number-of-graphs number-of-nodes type n))
                (loop for data in result and index from 0 do
                    (push data (nth index metrics)))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress (- 100 n) 100 total-time))))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        metrics))

(defmethod metrics-small-world (number-of-graphs number-of-nodes type degree &optional &key (verbose nil))
    (let ((total-time 0) (metrics nil))
        (setf metrics '(nil nil nil nil nil))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics over p...")
                (terpri)))
        (do ((n 100 (1- n)))
            ((< n 0) metrics)
            (let ((start-time nil) (end-time nil) (result nil))
                (setf start-time (get-internal-real-time))
                (setf result (small-world-graphs-analysis number-of-graphs number-of-nodes type n degree))
                (loop for data in result and index from 0 do
                    (push data (nth index metrics)))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress (- 100 n) 100 total-time))))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        metrics))

(defmethod metrics-scale-free (number-of-graphs number-of-nodes type &optional &key (verbose nil))
    (let ((total-time 0) (metrics nil))
        (setf metrics '(nil nil nil nil nil))
        (when verbose
            (progn
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)
                (format t "Calculating metrics over p...")
                (terpri)))
        (do ((n 100 (1- n)))
            ((< n 0) metrics)
            (let ((start-time nil) (end-time nil) (result nil))
                (setf start-time (get-internal-real-time))
                (setf result (scale-free-graphs-analysis number-of-graphs number-of-nodes type (floor (* (1- number-of-nodes) (/ n 100)))))
                (loop for data in result and index from 0 do
                    (push data (nth index metrics)))
                (setf end-time (get-internal-real-time))
                (decf end-time start-time)
                (incf total-time end-time)
                (when verbose
                    (print-progress (- 100 n) 100 total-time))))
        (when verbose
            (progn
                (terpri)
                (format t "Done!")
                (terpri)
                (dotimes (n 50)
                    (princ "#"))
                (terpri)))
        metrics))
